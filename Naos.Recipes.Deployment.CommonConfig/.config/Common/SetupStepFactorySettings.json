{
    "rootPackageDirectoriesToPrune": ["tools", "ref", "runtimes", "analyzers"],
    "initializationStrategyTypesThatNeedPackageBytes": ["Naos.Deployment.Domain.InitializationStrategyIis, Naos.Deployment.Domain","Naos.Deployment.Domain.InitializationStrategyMessageBusHandler, Naos.Deployment.Domain","Naos.Deployment.Domain.InitializationStrategyScheduledTask, Naos.Deployment.Domain","Naos.Deployment.Domain.InitializationStrategySelfHost, Naos.Deployment.Domain"],
    "initializationStrategyTypesThatNeedEnvironmentCertificate": ["Naos.Deployment.Domain.InitializationStrategyIis, Naos.Deployment.Domain","Naos.Deployment.Domain.InitializationStrategyMessageBusHandler, Naos.Deployment.Domain","Naos.Deployment.Domain.InitializationStrategyScheduledTask, Naos.Deployment.Domain","Naos.Deployment.Domain.InitializationStrategySelfHost, Naos.Deployment.Domain"],
    "maxSetupStepAttempts": 10,
    "throwOnFailedSetupStep": true,
    "rootDeploymentPath": "D:\\Deployments",
    "environmentEnvironmentVariableName": "Environment",
    "administratorAccount": "Administrator",
    "harnessSettings": {
        "harnessAccount": "NT AUTHORITY\\NETWORKSERVICE"
    },
    "mongoServerSettings": {
        "serviceAccount": "SYSTEM",
        "serviceName": "MongoDB",
        "defaultDataDirectory": "D:\\MongoData",
        "defaultLogDirectory": "D:\\MongoLog",
        "mongoServerPackage": { "id": "mongodb", "version": "3.2.7" },
        "mongoClientPackage": { "id": "robomongo", "version": "" }
    },
    "databaseServerSettings": {
        "sqlServiceName": "MSSQLSERVER",
        "sqlServiceAccount": "NT SERVICE\\MSSQLSERVER",
        "backupProcessServiceAccount": "NT AUTHORITY\\NETWORKSERVICE",
        "defaultBackupDirectory": "D:\\SqlBackup\\",
        "defaultDataDirectory": "D:\\SqlData\\"
    },
    "webServerSettings": {
        "iisAccount": "NT AUTHORITY\\NETWORKSERVICE"
    },
    "defaultDatabaseFileSizeSettings": {
        "dataFileCurrentSizeInKb": 100000,
        "dataFileMaxSizeInKb": 10000000,
        "dataFileGrowthSizeInKb": 10000,
        "logFileCurrentSizeInKb": 100000,
        "logFileMaxSizeInKb": 10000000,
        "logFileGrowthSizeInKb": 10000
    },
    "deploymentScriptBlocks": {
        "enableScheduledTaskHistory": {
            "parameterNames": [ ],
            "scriptTextLines": [
                "{",
                "   # crazy black magic - apparently the only way to do this...",
                "   # http://stackoverflow.com/questions/23227964/how-can-i-enable-all-tasks-history-in-powershell",
                "   $logName = 'Microsoft-Windows-TaskScheduler/Operational'",
                "   $log = New-Object System.Diagnostics.Eventing.Reader.EventLogConfiguration $logName",
                "   $log.IsEnabled=$true",
                "   $log.SaveChanges()",
                "}"
            ]
        },
        "updateWindowsRegistryEntries": {
            "parameterNames": [ "EntryUpdates" ],
            "scriptTextLines": [
                "{",
                "param([Array] $EntryUpdates)",
                "# -----Documentation of the 'PropertyType' that can be provided and how it maps to the native types----",
                "# MSDN article for Microsoft.Win32.RegistryValueKind shows the full map",
                "# PowerShell type	Registry type",
                "# Binary	REG_BINARY",
                "# DWord	REG_DWORD",
                "# ExpandString	REG_EXPAND_SZ",
                "# MultiString	REG_MULTI_SZ",
                "# None	–",
                "# QWord	REG_QWORD",
                "# String	REG_SZ",
                "# Unknown	–",
                "# ----------------------------------------------------------------------------------------------------",
                "   $EntryUpdates | %{",
                "       Write-Output \"Setting '$($_.Path) - $($_.Name)' to '$($_.Value) - $($_.Type)'\"",
                "       New-ItemProperty -Path $_.Path -Name $_.Name -Value $_.Value -PropertyType $_.Type -Force",
                "   }",
                "}"
            ]
        },
        "setupScheduledTask": {
            "parameterNames": [ "Name", "Description", "ScheduledTaskAccount", "ScheduledTaskPassword", "ExeFullPath", "Arguments", "DateTime", "RepetitionInterval", "DaysOfWeek" ],
            "scriptTextLines": [
                "{",
                "param([String] $Name, [String] $Description, [String] $ScheduledTaskAccount, [String] $ScheduledTaskPassword, [String] $ExeFullPath, [String] $Arguments, [DateTime] $DateTime, [TimeSpan] $RepetitionInterval, [Array] $DaysOfWeek)",
                "   $settings = New-ScheduledTaskSettingsSet -StartWhenAvailable -MultipleInstances 'IgnoreNew'",
                "   $trigger = $null",
                "   if ($RepetitionInterval -eq ([TimeSpan]::FromDays(1)))",
                "   {",
                "       # Daily...",
                "       $trigger = New-ScheduledTaskTrigger -Daily -At $DateTime -DaysInterval 1",
                "   }",
                "   elseif ($DaysOfWeek.Length -gt 0)",
                "   {",
                "       # Weekly...",
                "       $trigger = New-ScheduledTaskTrigger -Weekly -At $DateTime -WeeksInterval 1 -DaysOfWeek $DaysOfWeek",
                "   }",
                "   else",
                "   {",
                "       # Minutely or Hourly...",
                "       $trigger = New-ScheduledTaskTrigger -Once -At $DateTime -RepetitionDuration $([TimeSpan]::MaxValue) -RepetitionInterval $RepetitionInterval",
                "   }",
                "   $action = $null",
                "   if ([String]::IsNullOrEmpty($Arguments))",
                "   {",
                "       $action = New-ScheduledTaskAction -Execute $ExeFullPath",
                "   }",
                "   else",
                "   {",
                "       $action = New-ScheduledTaskAction -Execute $ExeFullPath -Argument $Arguments",
                "   }",
                "   if ([String]::IsNullOrEmpty($ScheduledTaskPassword))",
                "   {",
                "       Register-ScheduledTask -Action $action -Trigger $trigger -TaskName $Name -Description $Description -Settings $settings -RunLevel 'Highest' -User $ScheduledTaskAccount",
                "   }",
                "   else",
                "   {",
                "       Register-ScheduledTask -Action $action -Trigger $trigger -TaskName $Name -Description $Description -Settings $settings -RunLevel 'Highest' -User $ScheduledTaskAccount -Password $ScheduledTaskPassword",
                "   }",
                "}"
            ]
        },
        "configureMongo": {
            "parameterNames": [ "DatabaseName", "AdminPassword", "DataDirectory", "LogDirectory", "NoJournaling" ],
            "scriptTextLines": [
                "{",
                "param([String] $DatabaseName, [String] $AdminPassword, [String] $DataDirectory, [String] $LogDirectory, [boolean] $NoJournaling)",
                "   $logFilePath = Join-Path $LogDirectory mongod.log",
                "",
                "   $installLogPath = Join-Path (Split-Path $DataDirectory) 'MongoInstall.log'",
                "",
                "   \"Starting; DbName: $DatabaseName, Pwd (char count): $($AdminPassword.Length), DataDir: $DataDirectory, LogDir: $LogDirectory\" | Out-File -Append -FilePath $installLogPath",
                "",
                "   # In case we're on a retry attempt to stop first...",
                "    try {",
                "       Stop-Service MongoDB -ErrorAction SilentlyContinue",
                "    }",
                "    catch {",
                "      \"Error stopping mongo: $_\" | Out-File -Append -FilePath $installLogPath",
                "    }",
                "",
                "   $mongoPath = 'C:\\Program Files\\MongoDB\\Server\\3.2\\bin\\mongo.exe'",
                "   $mongodPath = 'C:\\Program Files\\MongoDB\\Server\\3.2\\bin\\mongod.exe'",
                "",
                "   # setup service using no auth",
                "   'Creating db and logs directories...' | Out-File -Append -FilePath $installLogPath",
                "   if (-not (Test-Path $DataDirectory)) {",
                "      md $DataDirectory",
                "   }",
                "",
                "   if (-not (Test-Path $LogDirectory)) {",
                "      md $LogDirectory",
                "   }",
                "",
                "   # create config file",
                "   $scriptsDir = Join-Path $DataDirectory 'Scripts'",
                "   md $scriptsDir -Force",
                "",
                "   # Super admin user",
                "   $superAdmin = 'sa' + $DatabaseName",
                "",
                "   # This script will create the local db user account.",
                "   $createSuperAdminUserScriptPath = Join-Path $scriptsDir \"CreateSuperAdminUserScript$DatabaseName.js\"",
                "   $createSuperAdminUserScript = ''",
                "   $createSuperAdminUserScript = $createSuperAdminUserScript + \"db.createUser({user:'$superAdmin',pwd:'$AdminPassword',roles:[{role:'userAdminAnyDatabase',db:'admin'},{role:'root',db:'admin'}]});\"",
                "   $createSuperAdminUserScript | Out-File -Encoding ASCII -FilePath $createSuperAdminUserScriptPath",
                "",
                "   # This script will create the local db user account.",
                "   $createAdminUserScriptPath = Join-Path $scriptsDir \"CreateAdminUserScript$DatabaseName.js\"",
                "   $createAdminUserScript = ''",
                "   $createAdminUserScript = $createAdminUserScript + \"db = db.getSiblingDB('$DatabaseName');\" + [Environment]::NewLine",
                "   $createAdminUserScript = $createAdminUserScript + \"db.createUser({user:'sa',pwd:'$AdminPassword',roles:[{role:'readWrite',db:'$DatabaseName'}]});\"",
                "   $createAdminUserScript | Out-File -Encoding ASCII -FilePath $createAdminUserScriptPath",
                "",
                "   $authTemplateToken = 'AuthTokenValue'",
                "   $configFilePath = Join-Path $DataDirectory 'mongod.cfg'",
                "   $configFileContentsTemplate = 'systemLog:' + [Environment]::NewLine + ' destination: file' + [Environment]::NewLine + ' path: ' + $logFilePath + [Environment]::NewLine +   'storage:' + [Environment]::NewLine +   ' dbPath: ' + $DataDirectory + [Environment]::NewLine + ' engine: \"wiredTiger\"' + [Environment]::NewLine +   'security:' + [Environment]::NewLine +' authorization: ' + $authTemplateToken + [Environment]::NewLine",
                "   $configFileContentsNoAuth = $configFileContentsTemplate -replace $authTemplateToken, 'disabled'",
                "   $configFileContentsAuth =  $configFileContentsTemplate -replace $authTemplateToken, 'enabled'",
                "   $configFileContentsNoAuth | Out-File -Encoding ASCII -FilePath $configFilePath",
                "",
                "   'Installing MongoDB Service...' | Out-File -Append -FilePath $installLogPath",
                "   if ($NoJournaling)",
                "   {",
                "      &$mongodPath --nojournal --config \"$configFilePath\" --install",
                "   }",
                "   else",
                "   {",
                "      &$mongodPath --config \"$configFilePath\" --install",
                "   }",
                "",
                "   'Starting MongoDB Service...' | Out-File -Append -FilePath $installLogPath",
                "   Start-Sleep 2",
                "   Start-Service MongoDB",
                "",
                "   'Create sa (superuser)...' | Out-File -Append -FilePath $installLogPath",
                "   &$mongoPath admin $createSuperAdminUserScriptPath",
                "",
                "   \"Create '$DatabaseName' database admin...\" | Out-File -Append -FilePath $installLogPath",
                "   &$mongoPath -u $superAdmin -p $AdminPassword admin $createAdminUserScriptPath",
                "",
                "   # change config to auth",
                "    try {",
                "       Stop-Service MongoDB -ErrorAction Stop",
                "    }",
                "    catch {",
                "      \"Error stopping mongo: $_\" | Out-File -Append -FilePath $installLogPath",
                "    }",
                "   # set to auto restart (survive reboot)",
                "    try {",
                "       sc.exe config MongoDb start=delayed-auto",
                "       # Needs delayed start... - Set-Service MongoDB -StartupType Automatic",
                "    }",
                "    catch {",
                "      \"Error setting auto restart on mongo: $_\" | Out-File -Append -FilePath $installLogPath",
                "    }",
                "   Start-Sleep 2",
                "   $configFileContentsAuth | Out-File -Encoding ASCII -FilePath $configFilePath",
                "   Start-Service MongoDB -ErrorAction Stop",
                "   Start-Sleep 2",
                "   # Remove-Item $scriptsDir -Force -Recurse",
                "   # Remove-Item $installLogPath -Force -Recurse",
                "}"

            ]
        },
        "configureSslCertificateForHosting": {
            "parameterNames": [ "CertStoreLocation", "CertStoreName", "CertThumbprint", "ApplicationId", "HttpsDnsEntries" ],
            "scriptTextLines": [
                "{",
                "param([string] $CertStoreLocation, [string] $CertStoreName, [string] $CertThumbprint, [System.Guid] $ApplicationId, [Array] $HttpsDnsEntries)",
                "   Write-Output \" CertStoreLocation: $CertStoreLocation\"",
                "   Write-Output \"     CertStoreName: $CertStoreName\"",
                "   Write-Output \"    CertThumbprint: $CertThumbprint\"",
                "   Write-Output \"     ApplicationId: $ApplicationId\"",
                "   Write-Output \"   HttpsDnsEntries: $([System.String]::Join(',', $HttpsDnsEntries))\"",
                "   if ($CertStoreLocation -ne 'LocalMachine') {",
                "      throw $('Can not configure certificates outside of LocalMachine for Self Hosting; specified: ' + $CertStoreLocation)",
                "   }",
                "   $certFullPath = Join-Path (Join-Path (Join-Path 'cert:' $CertStoreLocation) $CertStoreName) $CertThumbprint",
                "   $cert = Get-Item $certFullPath",
                "   if ($cert -eq $null)",
                "   {",
                "      throw \"Cert missing at $certFullPath\"",
                "   }",
                "   $HttpsDnsEntries | %{",
                "       $hostNamePort = \"$($_):443\"",
                "       Write-Output \"HostNamePort: $hostNamePort\"",
                "       netsh http add sslcert hostnameport=$hostNamePort appid=\"{$($ApplicationId)}\" certhash=$CertThumbprint certstorename=$CertStoreName",
                "   }",
                "}"
            ]
        },
        "configureUserForHosting": {
            "parameterNames": [ "User", "HttpsDnsEntries" ],
            "scriptTextLines": [
                "{",
                "param([string] $User, [Array] $HttpsDnsEntries)",
                "   $HttpsDnsEntries | %{",
                "       $url = \"https://$($_):443/\"",
                "       Write-Output \"Url: $url\"",
                "       netsh http add urlacl url=$url user=$User",
                "   }",
                "}"
            ]
        },
        "openPort": {
            "parameterNames": [ "Port", "Description" ],
            "scriptTextLines": [
                "{",
                "param([string] $Port, [string] $Description)",
                "   # Turn firewall off then back on to reset service...",
                "   netsh advfirewall firewall add rule name=\"$Description\" dir=in action=allow protocol=TCP localport=$Port",
                "   # Turn firewall off then back on to reset service and load the updated rules...",
                "   netsh advfirewall set allprofiles state off",
                "   netsh advfirewall set allprofiles state on",
                "   # Confirm that the firewall is enabled to make sure any issue results in a failed deployment",
                "   $firewallCheck = netsh advfirewall show all state",
                "   Write-Output $firewallCheck",
                "   $isOn = $(($firewallCheck[3] -eq 'State                                 ON') -and ($firewallCheck[7] -eq 'State                                 ON') -and ($firewallCheck[11] -eq 'State                                 ON'))",
                "   if (-not $isOn) {",
                "   	throw 'Firewall did not restart as expected, it is currently OFF'",
                "   }",
                "}"
            ]
        },
        "installChocolatey": {
            "parameterNames": [ ],
            "scriptTextLines": [
                "{",
                "param()",
                "   # can't use write-host b/c we're in interactive mode",
                "   iex (((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1') -ireplace 'Write-Host', 'Write-Output'))",
                "}"
            ]
        },
        "installChocolateyPackages": {
            "parameterNames": [ "Packages" ],
            "scriptTextLines": [
                "{",
                "param([Array] $Packages)",
                "   $Packages | ?{[String]::IsNullOrEmpty($_.Version)} | %{ ",
                "    #  try {",
                "         cinst $_.Id -y",
                "    #  }",
                "    #  catch {",
                "    #     Write-Output $_",
                "    #  }",
                "   }",
                "   $Packages | ?{![String]::IsNullOrEmpty($_.Version)} | %{ ",
                "    #  try {",
                "         cinst $_.Id -Version $_.Version -y",
                "    #  }",
                "    #  catch {",
                "    #     Write-Output $_",
                "    #  }",
                "   }",
                "}"
            ]
        },
        "downloadS3Object": {
            "parameterNames": [ "BucketName", "ObjectKey", "FilePath", "Region", "AccessKey", "SecretKey" ],
            "scriptTextLines": [
                "{",
                "param([string] $BucketName, [string] $ObjectKey, [string] $FilePath, [string] $Region, [string] $AccessKey, [string] $SecretKey)",
                "Read-S3Object -BucketName $BucketName -Key $ObjectKey -File $FilePath -Region $Region -AccessKey $AccessKey -SecretKey $SecretKey",
                "}"
            ]
        },
        "updateItsConfigPrecedence": {
            "parameterNames": [
                "FilePath",
                "PrecedenceChain"
            ],
            "scriptTextLines": [
                "{",
                "param([string] $FilePath, [Array] $PrecedenceChain)",
                "    $appSettingsNodeName = 'appSettings'",
                "    [xml] $c = Get-Content $FilePath",
                "    # should only be one so this 'hack' works",
                "    $appSettingsNode = $c.configuration.GetElementsByTagName($appSettingsNodeName) | %{$_}",
                "    if ($appSettingsNode -eq $null)",
                "    {",
                "       $appSettingsNode = $c.CreateElement($appSettingsNodeName)",
                "       $c.configuration.AppendChild($appSettingsNode)",
                "    }",
                "    $itsConfigPrecedenceKey = 'Its.Configuration.Settings.Precedence'",
                "    $n = $appSettingsNode.GetElementsByTagName('add') | ?{$_.key -eq $itsConfigPrecedenceKey}",
                "    $precedence = ''",
                "    $PrecedenceChain | %{",
                "       if (-not ([string]::IsNullOrEmpty($precedence)))",
                "       {",
                "           $precedence = $precedence + '|'",
                "       }",
                "       $precedence = $precedence + $_",
                "    }",
                "    if ($n -eq $null)",
                "    {",
                "       $n = $c.CreateElement('add') ",
                "       $appSettingsNode.AppendChild($n)",
                "       $n.SetAttribute('key',  $itsConfigPrecedenceKey)",
                "       $n.SetAttribute('value',  \"$precedence\")",
                "    }",
                "    else",
                "    {",
                "       $n.value = $precedence",
                "    }",
                "    $c.Save($FilePath)",
                "}"
            ]
        },
        "installCertificate": {
            "parameterNames": [
                "CertPath",
                "CertPassword",
                "InstallExportable",
                "UsersToGrantPrivateKeyAccess"
            ],
            "scriptTextLines": [
                "{",
                "param([string] $CertPath, [SecureString] $CertPassword, [boolean] $InstallExportable, [Array] $UsersToGrantPrivateKeyAccess = $null)",
                "   $certStoreLocation = 'cert:\\LocalMachine\\My'",
                "   Write-Output \"Installing cert at $certStoreLocation\"",
                "   if ($InstallExportable) {",
                "      $certResult = Import-PfxCertificate -FilePath $CertPath -Password $CertPassword -CertStoreLocation $certStoreLocation -Exportable",
                "   }",
                "   else {",
                "      $certResult = Import-PfxCertificate -FilePath $CertPath -Password $CertPassword -CertStoreLocation $certStoreLocation",
                "   }",
                "",
                "   if ($UsersToGrantPrivateKeyAccess -ne $null)",
                "   {",
                "      $keyname = (((gci $certStoreLocation | ? {$_.thumbprint -like $($certResult.Thumbprint)}).PrivateKey).CspKeyContainerInfo).UniqueKeyContainerName",
                "      $keypath = Join-Path $env:ProgramData \"Microsoft\\Crypto\\RSA\\MachineKeys\"",
                "      $fullpath = Join-Path $keypath $keyname",
                "      $UsersToGrantPrivateKeyAccess | %{",
                "          icacls $fullpath /grant $_`:RX",
                "      }",
                "   }",
                "",
                "   rm $CertPath -Force",
                "   Write-Output \"Cert installed with Thumbprint: $($certResult.Thumbprint) - Deleted file\"",
                "}"
            ]
        },
        "installAndConfigureWebsite": {
            "parameterNames": [
                "WebRootPath",
                "Domain",
                "CertStoreLocation",
                "CertStoreName",
                "CertThumbprint",
                "AppPoolAccount",
                "AppPoolPassword",
                "AppPoolStartMode",
                "AutoStartProviderName",
                "AutoStartProviderType",
                "EnableSNI",
                "AddHostHeaders",
                "EnableHttp"
            ],
            "scriptTextLines": [
                "{",
                "param([string] $WebRootPath, [string] $Domain, [string] $CertStoreLocation, [string] $CertStoreName, [string] $CertThumbprint, [string] $AppPoolAccount, [string] $AppPoolPassword, [string] $AppPoolStartMode, [string] $AutoStartProviderName, [string] $AutoStartProviderType, [switch] $EnableSNI, [switch] $AddHostHeaders, [switch] $EnableHttp)",
                "   Write-Output \"Beginning Deployment of a Website:\"",
                "   Write-Output \"       WebRootPath: $WebRootPath\"",
                "   Write-Output \"            Domain: $Domain\"",
                "   Write-Output \" CertStoreLocation: $CertStoreLocation\"",
                "   Write-Output \"     CertStoreName: $CertStoreName\"",
                "   Write-Output \"    CertThumbprint: $CertThumbprint\"",
                "   Write-Output ''",
                "   # Add IIS and suppporting features",
                "   Add-WindowsFeature -IncludeManagementTools -Name Web-Default-Doc, Web-Dir-Browsing, Web-Http-Errors, Web-Static-Content, Web-Http-Redirect, Web-Http-Logging, Web-Custom-Logging, Web-Log-Libraries, Web-Request-Monitor, Web-Http-Tracing, Web-Basic-Auth, Web-Digest-Auth, Web-Windows-Auth, Web-Net-Ext, Web-Net-Ext45, Web-Asp-Net, Web-Asp-Net45, Web-ISAPI-Ext, Web-ISAPI-Filter, Web-Scripting-Tools, NET-Framework-45-ASPNET",
                "   # Set IIS Service to restart on failure and reboot on 3rd failure",
                "   $services = Get-WMIObject win32_service | Where-Object {$_.name -imatch 'W3SVC' -and $_.startmode -eq 'Auto'}; foreach ($service in $services){sc.exe failure $service.name reset= 86400 actions= restart/5000/restart/5000/reboot/5000}",
                "   Import-Module WebAdministration",
                "   Write-Output \"Using site path for IIS at $WebRootPath\"",
                "   Write-Output 'Removing default site if present to avoid any potential conflicts'",
                "   if (Test-Path 'IIS:\\Sites\\Default Web Site'){ Remove-Item 'IIS:\\Sites\\Default Web Site' -Force -Recurse}",
                "   if (-not (Test-Path $WebRootPath))",
                "   {",
                "      throw \"Site missing at $WebRootPath\"",
                "   }",
                "   # cutting to first 50 chars to avoid the 64 char limit...",
                "   $limit = 50",
                "   $trimmedDomain = ''",
                "   if ($Domain.Length -gt $limit){$trimmedDomain = $Domain.SubString(0, $limit)}else{$trimmedDomain = $Domain}",
                "   $appPoolName = \"$($trimmedDomain)_AppPool\"",
                "   $appPoolPath = \"IIS:\\AppPools\\$appPoolName\"",
                "   if (Test-Path $appPoolPath)",
                "   {",
                "      Write-Output 'Removing existing app pool'",
                "      Remove-Item $appPoolPath -Force -Recurse",
                "   }",
                "   Write-Output \"Creating Application Pool: $appPoolName\" -Force",
                "   New-Item $appPoolPath",
                "   $appPoolIdentity = $null",
                "   if (-not [string]::IsNullOrEmpty($AppPoolAccount)) {",
                "      if (($AppPoolAccount -like 'NT AUTHORITY\\NetworkService') -or ($AppPoolAccount -like 'NetworkService')) {",
                "         $appPoolIdentity = @{ identityType = 'NetworkService' }",
                "      }",
                "      elseif (($AppPoolAccount -like 'NT AUTHORITY\\LocalService') -or ($AppPoolAccount -like 'LocalService')) {",
                "         $appPoolIdentity = @{ identityType = 'LocalService' }",
                "      }",
                "      elseif (($AppPoolAccount -like 'NT AUTHORITY\\LocalSystem') -or ($AppPoolAccount -like 'LocalSystem')) {",
                "         $appPoolIdentity = @{ identityType = 'LocalSystem' }",
                "      }",
                "      elseif (($AppPoolAccount -like 'IIS APPPOOL\\DefaultAppPool') -or ($AppPoolAccount -like 'DefaultAppPool')) {",
                "         $appPoolIdentity = $null",
                "      }",
                "      else {",
                "         $appPoolIdentity = @{ username = $AppPoolAccount; password = $AppPoolPassword; identityType = 'SpecificUser' }",
                "      }",
                "      if($appPoolIdentity -ne $null) {",
                "         Set-ItemProperty -Path $appPoolPath processModel $appPoolIdentity",
                "      }",
                "   }",
                "   Set-ItemProperty -Path $appPoolPath managedRuntimeVersion v4.0",
                "   Set-ItemProperty -Path $appPoolPath startMode $AppPoolStartMode",
                "   Set-ItemProperty -Path $appPoolPath autoStart true",
                "   Set-ItemProperty -Path $appPoolPath -Name processModel.idleTimeout -Value ([TimeSpan]::FromMinutes(0))",
                "   Set-ItemProperty -Path $appPoolPath -Name recycling.periodicrestart.time -Value ([TimeSpan]::FromMinutes(0))",
                "   $sslFlags = 0",
                "   if ($EnableSNI)",
                "   {",
                "      $sslFlags = 1",
                "      Write-Output \"SNI Enabled (can use multiple host names on same machine\"",
                "   }",
                "   else",
                "   {",
                "      Write-Output \"SNI is NOT Enabled (can NOT use multiple host names on same machine\"",
                "   }",
                "",
                "   $sitePath = \"IIS:\\Sites\\$Domain\"",
                "   if (Test-Path $sitePath)",
                "   {",
                "      Write-Output 'Removing existing site and all bindings'",
                "      Get-WebBinding | %{ $_ | Remove-WebBinding }",
                "      ls IIS:\\SslBindings | %{ $_ | Remove-item -Force -Recurse }",
                "      Remove-Item $sitePath -Force -Recurse",
                "   }",
                "",
                "   $binding = $null",
                "   if ($AddHostHeaders)",
                "   {",
                "      $binding = @{protocol=\"http\";bindingInformation=\":80:$Domain\"}",
                "      Write-Output \"Creating site at $WebRootPath for domain $Domain WITH hostHeaders\"",
                "      New-Item -Path $sitePath -bindings $binding -physicalPath $WebRootPath -applicationPool $appPoolName",
                "      New-WebBinding -name $Domain -Protocol https -HostHeader \"$Domain\" -Port 443 -SslFlags $sslFlags",
                "   }",
                "   else",
                "   {",
                "      $binding = @{protocol=\"http\";bindingInformation=\":80:\"}",
                "      Write-Output \"Creating site at $WebRootPath for domain $Domain WITH OUT hostHeaders\"",
                "      New-Item -Path $sitePath -bindings $binding -physicalPath $WebRootPath -applicationPool $appPoolName",
                "      New-WebBinding -name $Domain -Protocol https -Port 443 -SslFlags $sslFlags",
                "   }",
                "",
                "   if (-not $EnableHttp)",
                "   {",
                "      Write-Output 'Removing http binding since its not specified to be enabled'",
                "      Get-WebBinding |?{($_.protocol -eq $binding.protocol) -and ($_.bindingInformation -eq $binding.bindingInformation)} | Remove-WebBinding",
                "   }",
                "",
                "   $certFullPath = Join-Path (Join-Path (Join-Path 'cert:' $CertStoreLocation) $CertStoreName) $CertThumbprint",
                "   $cert = Get-Item $certFullPath",
                "   if ($cert -eq $null)",
                "   {",
                "      throw \"Cert missing at $certFullPath\"",
                "   }",
                "   New-Item -Path \"IIS:\\SslBindings\\!443!$Domain\" -Value $cert -SSLFlags $sslFlags",
                "   Write-Output 'Performing IIS RESET to make sure everything is up and running correctly'",
                "   iisreset",
                "   $site = Get-Item $sitePath -ErrorAction SilentlyContinue",
                "   $newSitePath = $site.physicalPath",
                "   if ($newSitePath -ne $WebRootPath)",
                "   {",
                "      throw \"Failed to correctly deploy site to $WebRootPath, instead it got configured to $newSitePath\"",
                "   }",
                "   if ((-not [String]::IsNullOrEmpty($AutoStartProviderName)) -and (-not ([String]::IsNullOrEmpty($AutoStartProviderType))))",
                "   {",
                "       Set-ItemProperty $sitePath serverAutoStart true",
                "       Set-ItemProperty $sitePath 'applicationDefaults.serviceAutoStartEnabled' true",
                "       Set-ItemProperty $sitePath 'applicationDefaults.serviceAutoStartProvider' $AutoStartProviderName",
                "       [xml]$appHost = New-Object xml",
                "       $appHost.psbase.PreserveWhitespace = $true",
                "       $configPath = 'C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config'",
                "       $appHost.Load($configPath)",
                "       $appHost.configuration.'system.applicationHost'",
                "       $autoStartProviders = $appHost.configuration.'system.applicationHost'.serviceAutoStartProviders",
                "       if ($autoStartProviders -eq $null)",
                "       {",
                "          $autoStartProviders = $appHost.CreateElement('serviceAutoStartProviders')",
                "          $appHost.configuration.'system.applicationHost'.AppendChild($autoStartProviders)",
                "       }",
                "       $existingProvider = $autoStartProviders.add | ?{$_.name -eq $AutoStartProviderName}",
                "       if ($existingProvider -eq $null)",
                "       {",
                "          $provider = $appHost.CreateElement('add')",
                "          $provider.SetAttribute('name', $AutoStartProviderName)",
                "          $provider.SetAttribute('type', $AutoStartProviderType)",
                "          $autoStartProviders.AppendChild($provider)",
                "       }",
                "      $appHost.Save($configPath)",
                "   }",
                "   Write-Output 'Performing IIS RESET to make sure everything is up and running correctly'",
                "   iisreset",
                "   $deploymentInfo = join-path $WebRootPath \"deploymentInfo.xml\"",
                "   Write-Output \"Writing deployment info to $deploymentInfo\"",
                "   $xmlWriter = New-Object System.XML.XmlTextWriter($deploymentInfo,$Null)",
                "   # choose a pretty formatting:",
                "   $xmlWriter.Formatting = 'Indented'",
                "   $xmlWriter.Indentation = 1",
                "   $xmlWriter.IndentChar = ' '",
                "   $xmlWriter.WriteStartDocument()",
                "   $xmlWriter.WriteStartElement('Publish')",
                "   $xmlWriter.WriteElementString('SitePath',$WebRootPath)",
                "   $xmlWriter.WriteElementString('Domain',$Domain)",
                "   $xmlWriter.WriteElementString('AppPool',$appPoolName)",
                "   $xmlWriter.WriteElementString('Username',[Environment]::Username)",
                "   $xmlWriter.WriteElementString('UserDomainName',[Environment]::UserDomainName)",
                "   $xmlWriter.WriteElementString('MachineName',[Environment]::MachineName)",
                "   $xmlWriter.WriteElementString('PublishDate',[System.DateTime]::Now.ToString('yyyyMMdd-HHmm'))",
                "   $xmlWriter.WriteEndElement()",
                "   $xmlWriter.WriteEndDocument()",
                "   $xmlWriter.Flush()",
                "   $xmlWriter.Close()",
                "   Write-Output \"Finished successfully\"",
                "}"
            ]
        },
        "unzipFile": {
            "parameterNames": [
                "FilePath",
                "TargetDirectoryPath"
            ],
            "scriptTextLines": [
                "{",
                "param([string] $FilePath, [string] $TargetDirectoryPath)",
                "   $shell_app=new-object -com shell.application",
                "   $zip_file = $shell_app.namespace($FilePath)",
                "   $destination = $shell_app.namespace($TargetDirectoryPath)",
                "   $destination.Copyhere($zip_file.items())",
                "}"
            ]
        },
        "restartWindowsService": {
            "parameterNames": [
                "ServiceName"
            ],
            "scriptTextLines": [
                "{",
                "param([string] $ServiceName)",
                "if ([string]::IsNullOrEmpty($ServiceName))",
                "{",
                "   throw 'Must supply a service name.'",
                "}",
                "$servicePresentCheck = Get-Service | ?{$_.Name -ieq $ServiceName}",
                "if ($servicePresentCheck -eq $null)",
                "{",
                "   throw 'Service not installed: ' + $ServiceName",
                "}",
                "$svcName = $ServiceName ",
                "#Rest is from: http://www.blogmynog.com/2010/06/22/powershell-script-to-restart-service-and-dependents/",
                "####################################################",
                "## Usage: RestartService.ps1 <service name> ########",
                "## Author: Stephen Leuthold (http://blogmynog.com) #",
                "## Created: 6/22/2010 ##############################",
                "## Modified: 6/22/2010 #############################",
                "## Purpose: Restart service and dependencies #######",
                "####################################################",
                "# Get dependent services",
                "$depSvcs = Get-Service -name $svcName -dependentservices | Where-Object {$_.Status -eq 'Running'} |Select -Property Name",
                "# Check to see if dependent services are started",
                "if ($depSvcs -ne $null) {",
                "   # Stop dependencies",
                "   foreach ($depSvc in $depSvcs)",
                "   {",
                "      Stop-Service $depSvc.Name",
                "      do",
                "      {",
                "         $service = Get-Service -name $depSvc.Name | Select -Property Status",
                "         Start-Sleep -seconds 1",
                "      }",
                "      until ($service.Status -eq 'Stopped')",
                "   }",
                "}",
                "# Restart service",
                "Restart-Service $svcName -force",
                "$counter = 0;",
                "do",
                "{",
                "   $service = Get-Service -name $svcName | Select -Property Status",
                "   Start-Sleep -seconds 1",
                "   $counter = $counter + 1",
                "   if ($counter -gt 100)",
                "   {",
                "      throw 'Service ' + $svcName + ' was not [Running] after 100 seconds...investigate manually.'",
                "   }",
                "}",
                "until ($service.Status -eq 'Running')",
                "$depSvcs = Get-Service -name $svcName -dependentservices |Select -Property Name",
                "if ($depSvcs -ne $null) {",
                "   # We check for Auto start flag on dependent services and start them even if they were stopped before",
                "   foreach ($depSvc in $depSvcs)",
                "   {",
                "      $startMode = gwmi win32_service -filter \"NAME = '$($depSvc.Name)'\" | Select -Property StartMode",
                "      if ($startMode.StartMode -eq 'Auto') {",
                "         Start-Service $depSvc.Name",
                "         do",
                "         {",
                "            $service = Get-Service -name $depSvc.Name | Select -Property Status",
                "            Start-Sleep -seconds 1",
                "         }",
                "         until ($service.Status -eq 'Running')",
                "      }",
                "   }",
                "}",
                "}"
            ]
        },
        "createDirectoryWithFullControl": {
            "parameterNames": [
                "DirectoryPath",
                "UserToGiveFullControlTo"
            ],
            "scriptTextLines": [
                "{",
                "param([string] $DirectoryPath, [string] $UserToGiveFullControlTo)",
                "    if (-not (Test-Path $DirectoryPath)) { md $DirectoryPath }",
                "    $acl = Get-Acl $DirectoryPath",
                "    $permission = $UserToGiveFullControlTo, 'FullControl', 'Allow'",
                "    $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission",
                "    $acl.SetAccessRule($accessRule)",
                "    $acl | Set-Acl $DirectoryPath",
                "}"
            ]
        },
        "enableSaAccountAndSetPassword": {
            "parameterNames": [
                "SaPassword"
            ],
            "scriptTextLines": [
                "{",
                "param([string] $SaPassword)",
                "   [System.Reflection.Assembly]::LoadWithPartialName('Microsoft.SqlServer.SMO') | out-null",
                "   $smoServer = new-object ('Microsoft.SqlServer.Management.Smo.Server') 'localhost'",
                "   $smoServer.Settings.LoginMode = [Microsoft.SqlServer.Management.SMO.ServerLoginMode]::Mixed",
                "   $smoServer.Alter()",
                "   $sqlCmdExe = 'C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\110\\Tools\\Binn\\SQLCMD.EXE'",
                "   if (-not (Test-Path $sqlCmdExe)){ $sqlCmdExe = 'C:\\Program Files\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLCMD.EXE' }",
                "   $statementEnable = 'ALTER LOGIN sa ENABLE'",
                "   &$sqlCmdExe -Q \"$statementEnable\" -E",
                "   if($lastExitCode -ne 0) { throw \"Exitcode was expected 0 but was $lastExitCode - failed to run $sqlCmdExe -Q $statementEnable -E\" }",
                "   $statementPassword = \"ALTER LOGIN sa WITH PASSWORD = '\" + $SaPassword + \"'\"",
                "   &$sqlCmdExe -Q \"$statementPassword\" -E",
                "   if($lastExitCode -ne 0) { throw \"Exitcode was expected 0 but was $lastExitCode - failed to run $sqlCmdExe -Q $statementPassword -E\" }",
                "}"
            ]
        },
        "setDefaultDirectories": {
            "parameterNames": [
                "Data, Log, Backup"
            ],
            "scriptTextLines": [
                "{",
                "param([string] $Data, [string] $Log, [string] $Backup)",
                "   [System.Reflection.Assembly]::LoadWithPartialName('Microsoft.SqlServer.SMO') | out-null",
                "   $smoServer = new-object ('Microsoft.SqlServer.Management.Smo.Server') 'localhost'",
                "   $smoServer.Properties['DefaultFile'].Value = $Data",
                "   $smoServer.Properties['DefaultLog'].Value = $Log",
                "   $smoServer.Properties['BackupDirectory'].Value = $Backup",
                "   $smoServer.Alter()",
                "}"
            ]
        },
        "addMachineLevelEnvironmentVariables": {
            "parameterNames": [ "EnvironmentVariables" ],
            "scriptTextLines": [
                "{",
                "param([Array] $EnvironmentVariables)",
                "   $EnvironmentVariables | %{",
                "       Write-Output \"Setting '$($_.Name)' to '$($_.Value)'\"",
                "       [Environment]::SetEnvironmentVariable( $_.Name, $_.Value, 'Machine' )",
                "   }",
                "}"
            ]
        },
        "updateInstanceWallpaper": {
            "parameterNames": [ "EnvironmentVariables" ],
            "scriptTextLines": [
                "{",
                "param([Array] $EnvironmentVariables)",
                "   $wpsettings = 'C:\\Program Files\\Amazon\\Ec2ConfigService\\Settings\\WallpaperSettings.xml'",
                "   if (Test-Path $wpsettings) {",
                "      $xmlns      = 'http://tempuri.org/WallpaperSettings.xsd'",
                "      $wpxml      = [xml]( Get-Content $wpsettings )",
                "      $EnvironmentVariables | %{",
                "          $variableName = $_",
                "          $wpi = $wpxml.WallpaperSettings.AppendChild($wpxml.CreateElement( 'WallpaperInformation', $xmlns ) )",
                "          $elements = @{}",
                "          foreach ( $x in $( 'name', 'source', 'identifier' ) ) {",
                "              $elements.$x = $wpi.AppendChild( $wpxml.CreateElement( $x, $xmlns ) )",
                "          }",
                "          $name = $elements.name.AppendChild($wpxml.CreateTextNode( $variableName ) )",
                "          $source = $elements.source.AppendChild($wpxml.CreateTextNode( 'EnvironmentVariable' ) )",
                "          $identifier = $elements.identifier.AppendChild($wpxml.CreateTextNode( $variableName ) )",
                "      }",
                "      $wpxml.Save( $wpsettings )",
                "   }",
                "}"
            ]
        },
        "enableScriptExecutionScriptBlock": {
            "parameterNames": [ ],
            "scriptTextLines": [
                "{",
                "   # SETTING TO UNRESTRICTED TO ALLOW FOR SCRIPTS TO BE CALLED VIA MACHINE MANAGER (WINRM)",
                "   Set-ExecutionPolicy 'Unrestricted' -Force",
                "}"
            ]
        },
        "setupWindowsTimeScriptBlock": {
            "parameterNames": [ ],
            "scriptTextLines": [
                "{",
                "   # ADDING COMMANDS TO CONFIGURE TIME TO UPDATE AUTOMATICALLY (on by default but must restart the service)",
                "   NET STOP W32Time",
                "   NET START W32Time",
                "}"
            ]
        },
        "setupWindowsUpdatesScriptBlock": {
            "parameterNames": [ ],
            "scriptTextLines": [
                "{",
                "   # ADDING COMMANDS TO CONFIGURE WINDOWS UPDATE TO RUN EVERYDAY AT 3AM AND INSTALL IMPORTANT UPDATES AUTOMATICALLY",
                "   #$windowsUpdateSettings = (New-Object -com 'Microsoft.Update.AutoUpdate').Settings",
                "   #$windowsUpdateSettings.NotificationLevel = 4",
                "   #$windowsUpdateSettings.Save()",
                "}"
            ]
        },
        "setupWinRmScriptBlock": {
            "parameterNames": [ ],
            "scriptTextLines": [
                "{",
                "   # NEEDED TO ALLOW THE MACHINE TO MAKE WINRM CALLS ITSELF",
                "   Set-Item -Path WSMan:\\localhost\\client\\TrustedHosts -Value '' -Force",
                "   # SET SPECIFIC WINRM SETTINGS",
                "   #winrm set winrm/config '@{MaxTimeoutms=\"1800000\"}'",
                "   #net stop winrm",
                "   #sc.exe config winrm start=auto",
                "   #net start winrm",
                "}"
            ]
        },
        "renameComputerScriptBlock": {
            "parameterNames": [ "ComputerName" ],
            "scriptTextLines": [
                "{",
                "param([Array] $ComputerName)",
                "   # WILL REBOOT ON SEPARATE STEP",
                "   Rename-Computer -NewName \"$ComputerName\" -Force",
                "}"
            ]
        }
    }
}