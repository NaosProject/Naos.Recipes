// --------------------------------------------------------------------------------------------------------------------
// <copyright file="HashGenerator.cs" company="Naos">
//   Copyright 2017 Naos
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Naos.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Naos.Recipes.Cryptography.Hashing
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Security.Cryptography;
    using System.Text;

    using OBeautifulCode.Validation.Recipes;

    /// <summary>
    /// Helper class for computing hash values.
    /// </summary>
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Naos.Recipes", "See package version number")]
    internal static partial class HashGenerator
    {
        private static readonly IDictionary<HashAlgorithmName, Func<HashAlgorithm>> HashAlgorithmFactory =
            new Dictionary<HashAlgorithmName, Func<HashAlgorithm>>
            {
                { HashAlgorithmName.MD5, MD5.Create },
                { HashAlgorithmName.SHA1, SHA1.Create },
                { HashAlgorithmName.SHA256, SHA256.Create },
                { HashAlgorithmName.SHA384, SHA384.Create },
                { HashAlgorithmName.SHA512, SHA512.Create }
            };

        /// <summary>
        ///  Compute a hash value and returns a hexadecimal-formatted string.
        /// </summary>
        /// <param name="hashAlgorithmName">Name of the hash algorithm to use.</param>
        /// <param name="source">Source to use as the input.</param>
        /// <param name="encoding">Optional encoding of the input (default is UTF8).</param>
        /// <returns>Hexadecimal-formatted string of the hash value.</returns>
        public static string ComputeHashFromString(HashAlgorithmName hashAlgorithmName, string source, Encoding encoding = null)
        {
            source.Named(nameof(source)).Must().NotBeNullNorWhiteSpace();

            var localEncoding = encoding ?? Encoding.UTF8;

            using (var hashAlgorithm = GetHashAlgorithm(hashAlgorithmName))
            {
                var bytes = localEncoding.GetBytes(source);
                return CreateHashString(hashAlgorithm.ComputeHash(bytes));
            }
        }

        /// <summary>
        ///  Compute a hash value and returns a hexadecimal-formatted string.
        /// </summary>
        /// <param name="hashAlgorithmName">Name of the hash algorithm to use.</param>
        /// <param name="sourceStream">Source stream to use as the input.</param>
        /// <returns>Hexadecimal-formatted string of the hash value.</returns>
        public static string ComputeHashFromStream(HashAlgorithmName hashAlgorithmName, Stream sourceStream)
        {
            sourceStream.Named(nameof(sourceStream)).Must().NotBeNull();

            using (var hashAlgorithm = GetHashAlgorithm(hashAlgorithmName))
            {
                if (sourceStream.CanSeek)
                {
                    sourceStream.Position = 0;
                }

                return CreateHashString(hashAlgorithm.ComputeHash(sourceStream));
            }
        }

        /// <summary>
        ///  Compute a hash value and returns a hexadecimal-formatted string.
        /// </summary>
        /// <param name="hashAlgorithmName">Name of the hash algorithm to use.</param>
        /// <param name="sourceFilePath">Source file path to use as the input.</param>
        /// <returns>Hexadecimal-formatted string of the hash value.</returns>
        public static string ComputeHashFromFilePath(HashAlgorithmName hashAlgorithmName, string sourceFilePath)
        {
            sourceFilePath.Named(nameof(sourceFilePath)).Must().NotBeNullNorWhiteSpace();

            using (var hashAlgorithm = GetHashAlgorithm(hashAlgorithmName))
            {
                using (var file = File.OpenRead(sourceFilePath))
                {
                    return CreateHashString(hashAlgorithm.ComputeHash(file));
                }
            }
        }

        /// <summary>
        /// Gets a HashAlgorithm implementation based on the hash algorithm name.
        /// </summary>
        /// <param name="hashAlgorithmName">Name of the hash algorithm.</param>
        /// <returns>Hash algorithm to use in computing a hash value.</returns>
        private static HashAlgorithm GetHashAlgorithm(HashAlgorithmName hashAlgorithmName)
        {
            if (!HashAlgorithmFactory.ContainsKey(hashAlgorithmName))
            {
                throw new ArgumentOutOfRangeException(nameof(hashAlgorithmName), hashAlgorithmName, "Unsupported Hash Algorithm Name.");
            }

            return HashAlgorithmFactory[hashAlgorithmName]();
        }

        private static string CreateHashString(IEnumerable<byte> bytes)
        {
            var hashValue = new StringBuilder();

            foreach (var b in bytes)
            {
                hashValue.Append(b.ToString("x2", CultureInfo.InvariantCulture));
            }

            return hashValue.ToString();
        }
    }
}