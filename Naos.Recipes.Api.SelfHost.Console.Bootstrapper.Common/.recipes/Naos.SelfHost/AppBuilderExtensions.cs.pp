// --------------------------------------------------------------------------------------------------------------------
// <copyright file="AppBuilderExtensions.cs" company="Naos">
//   Copyright (c) Naos 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Naos.Recipes.Api.SelfHost.Bootstrapper.Common source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace $rootnamespace$
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.IO.Compression;
    using System.Linq;
    using System.Security.Cryptography;
    using System.Threading.Tasks;
    using System.Web.Cors;
    using Microsoft.Owin;
    using Microsoft.Owin.Cors;
    using Microsoft.Owin.Security.DataHandler.Encoder;
    using Microsoft.Owin.Security.OAuth;
    using Owin;
    using static System.FormattableString;

    /// <summary>
    /// Internal extensions to the <see cref="IAppBuilder" />.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Naos.Recipes.Api.SelfHost.Bootstrapper.Common", "See package version number")]
    internal static class AppBuilderExtensions
    {
        /// <summary>
        /// Setup CORS on the <see cref="IAppBuilder" />.
        /// </summary>
        /// <param name="app"><see cref="IAppBuilder" /> to setup.</param>
        /// <param name="hostingSettings">Hosting settings.</param>
        /// <returns>The modified application.</returns>
        public static IAppBuilder UseCors(this IAppBuilder app, HostingSettings hostingSettings)
        {
            var cors = hostingSettings.Cors;

            if (cors == null || !cors.Origins.Any())
            {
                throw new InvalidOperationException(Invariant($"Provided {nameof(HostingSettings)} did not have {nameof(HostingSettings.Cors)} configured."));
            }

            var corsPolicy = new CorsPolicy
            {
                SupportsCredentials = cors.SupportsCredentials,
                PreflightMaxAge = cors.PreflightMaxAge,
            };

            cors.Origins.ToList().ForEach(corsPolicy.Origins.Add);
            cors.Headers.ToList().ForEach(corsPolicy.Headers.Add);
            cors.Methods.ToList().ForEach(corsPolicy.Methods.Add);
            cors.ExposedHeaders.ToList().ForEach(corsPolicy.ExposedHeaders.Add);

            if (cors.Origins.FirstOrDefault(o => o == "*") != null)
            {
                corsPolicy.AllowAnyOrigin = true;
            }

            if (cors.Headers.FirstOrDefault(h => h == "*") != null)
            {
                corsPolicy.AllowAnyHeader = true;
            }

            if (cors.Methods.FirstOrDefault(m => m == "*") != null)
            {
                corsPolicy.AllowAnyMethod = true;
            }

            return app.UseCors(new CorsOptions
            {
                PolicyProvider = new CorsPolicyProvider
                {
                    PolicyResolver = request => Task.FromResult(corsPolicy),
                },
            });
        }

        /// <summary>
        /// Adds JWT token middleware to your web application pipeline with client settings
        /// resolved from the container.
        /// </summary>
        /// <param name="app">The application.</param>
        /// <param name="settings">
        /// The JWT bearer authentication settings. If unspecified an attempt will be made to load
        /// from the container.
        /// </param>
        /// <returns>The modified application.</returns>
        public static IAppBuilder UseJwtAuthentication(
            this IAppBuilder app,
            JwtAuthenticationSettings settings)
        {
            if (settings.RelativeFileCertificate != null && settings.StoreCertificate != null)
            {
                throw new InvalidOperationException(Invariant($"Must specify {nameof(JwtAuthenticationSettings)} with either {nameof(JwtAuthenticationSettings.RelativeFileCertificate)} OR {nameof(JwtAuthenticationSettings.StoreCertificate)} but not both."));
            }

            var privateKey = GetPrivateKey(settings);

            // Try decoding each secret so it will throw an exception early if there is a configuration problem
            settings.AllowedServers.ToList().ForEach(server => TextEncodings.Base64Url.Decode(server.Secret));

            var authenticationOptions = new OAuthBearerAuthenticationOptions
            {
                AccessTokenFormat = new JoseJwtFormat(settings, privateKey),
                AuthenticationType = "Bearer",
                Provider = new OAuthBearerAuthenticationProvider
                {
                    OnRequestToken = async context => await RequestToken(context, settings),
                },
            };

            return app.UseOAuthBearerAuthentication(authenticationOptions);
        }

        private static RSACryptoServiceProvider GetPrivateKey(JwtAuthenticationSettings settings)
        {
            var certificateFetcher =
                settings.RelativeFileCertificate != null
                    ? new FileCertificateFetcher(settings.RelativeFileCertificate)
                    : settings.StoreCertificate != null
                        ? new StoreByThumbprintCertificateFetcher(settings.StoreCertificate)
                        : null as ICertificateFetcher;

            RSACryptoServiceProvider privateKey = null;
            if (certificateFetcher != null)
            {
                var certificate = certificateFetcher.Fetch();

                if (certificate == null)
                {
                    throw new InvalidOperationException(Invariant($"Could not find certificate."));
                }

                privateKey = certificate.PrivateKey as RSACryptoServiceProvider;

                if (privateKey == null)
                {
                    throw new InvalidOperationException("No private key available for the certificate.");
                }
            }

            return privateKey;
        }

        private static async Task RequestToken(OAuthRequestTokenContext requestTokenContext, JwtAuthenticationSettings settings)
        {
            var originalToken = requestTokenContext.Token;

            if (!string.IsNullOrWhiteSpace(settings.AuthorizationKey))
            {
                requestTokenContext.Token = null;

                // Late bound to capture originalToken
                Func<OAuthRequestTokenContext, string, Task> useHeader = (context, _) =>
                {
                    if (!string.IsNullOrWhiteSpace(originalToken))
                    {
                        context.Token = originalToken;
                    }

                    return Task.FromResult<object>(null);
                };

                var setTokenLookup = new Dictionary<AuthorizationSource, Func<OAuthRequestTokenContext, string, Task>>
                {
                    { AuthorizationSource.Header, useHeader },
                    { AuthorizationSource.Form, UseForm },
                    { AuthorizationSource.QueryString, UseQueryString },
                };

                var authorizationPriority = (settings.AuthorizationPriority.Count > 0)
                    ? settings.AuthorizationPriority
                    : new[] { AuthorizationSource.Header, AuthorizationSource.Form, AuthorizationSource.QueryString };

                // Apply them last to first so that first gets highest priority when setting value
                var setTokens = authorizationPriority.Reverse().Select(a => setTokenLookup[a]);

                foreach (var setToken in setTokens)
                {
                    await setToken(requestTokenContext, settings.AuthorizationKey);
                }
            }
        }

        private static async Task UseForm(OAuthRequestTokenContext context, string authorizationKey)
        {
            // OWIN/Web API can only read from Body one time and then it is not available any longer
            // So make a copy of the original stream in memory and replace Body with that stream copy
            // Stream can now be repositioned after reading so system is unaware it has been accessed
            // System will dispose this instance and instead we dispose the Body instance for the system
            var memoryStream = new MemoryStream();

            await context.Request.Body.CopyToAsync(memoryStream);
            context.Request.Body.Dispose();

            memoryStream.Position = 0;
            context.Request.Body = memoryStream;

            // Read just as we would have on the original copy, but reset stream for downstream users
            var form = await context.Request.ReadFormAsync();
            memoryStream.Position = 0;

            var formValue = form.Get(authorizationKey);
            context.Token = string.IsNullOrWhiteSpace(formValue) ? context.Token : formValue;
        }

        private static Task UseQueryString(OAuthRequestTokenContext context, string authorizationKey)
        {
            if (!string.IsNullOrWhiteSpace(context.Request.QueryString.Value))
            {
                var keyValues = context.Request.QueryString.Value.Split(
                    new[] { '&' },
                    StringSplitOptions.RemoveEmptyEntries);

                keyValues
                    .Select(kv => kv.Split(new[] { '=' }, StringSplitOptions.RemoveEmptyEntries))
                    .Where(kv => kv.Length >= 2 && string.Compare(kv[0].Trim(), authorizationKey, StringComparison.OrdinalIgnoreCase) == 0)
                    .ToList()
                    .ForEach(kv => context.Token = kv[1]);
            }

            return Task.FromResult<object>(null);
        }

        private static IReadOnlyDictionary<string, Func<Stream, Stream>> createCompressionStream =
            new Dictionary<string, Func<Stream, Stream>>(StringComparer.OrdinalIgnoreCase)
            {
                {
                    "gzip",
                    destinationStream => new GZipStream(destinationStream, CompressionMode.Compress, leaveOpen: true)
                },
                {
                    "deflate",
                    destinationStream => new DeflateStream(destinationStream, CompressionMode.Compress, leaveOpen: true)
                },
            };

        /// <summary>
        /// Uses the g-zip deflate compression.
        /// </summary>
        /// <param name="app">The application.</param>
        /// <param name="compressResponsesOver">The size over which responses should be compressed.</param>
        /// <param name="bufferSize">Size of the buffer.</param>
        /// <returns>
        /// The modified application.
        /// </returns>
        public static IAppBuilder UseGzipDeflateCompression(this IAppBuilder app, int compressResponsesOver = 4096, int bufferSize = 8196)
        {
            if (app == null)
            {
                throw new ArgumentNullException(nameof(app));
            }

            app.Use(async (context, next) =>
            {
                var acceptEncoding = (context.Request.Headers["Accept-Encoding"] ?? string.Empty).ToLowerInvariant();
                var acceptedEncodings = acceptEncoding.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries).Select(s => s.Trim());
                var acceptedEncoding = acceptedEncodings.FirstOrDefault(e => createCompressionStream.ContainsKey(e));

                if (acceptedEncoding == null)
                {
                    await next.Invoke();
                }
                else
                {
                    // Copy original value and restore in finally
                    var body = context.Response.Body;
                    try
                    {
                        // Underlying source will be written to source
                        using (var responseStream = new MemoryStream())
                        {
                            context.Response.Body = responseStream;
                            await next.Invoke();

                            if (responseStream.Length <= compressResponsesOver)
                            {
                                await responseStream.CopyTo(body, context, bufferSize);
                            }
                            else
                            {
                                await responseStream.CompressTo(body, context, createCompressionStream, acceptedEncoding, bufferSize);
                            }
                        }
                    }
                    finally
                    {
                        context.Response.Body = body;
                    }
                }
            });

            return app;
        }

        private static async Task CompressTo(this Stream source, Stream destination, IOwinContext context, IReadOnlyDictionary<string, Func<Stream, Stream>> createCompressionStream, string acceptedEncoding, int bufferSize)
        {
            using (var compressedResponse = new MemoryStream())
            {
                // Need to open and close compression stream for it to write all info to output stream
                // See: https://blogs.msdn.microsoft.com/bclteam/2006/05/10/using-a-memorystream-with-gzipstream-lakshan-fernando/
                using (var compressionStream = createCompressionStream[acceptedEncoding](compressedResponse))
                {
                    source.Seek(0, SeekOrigin.Begin);
                    await source.CopyToAsync(compressionStream, bufferSize, context.Request.CallCancelled);
                }

                context.Response.Headers.Set("Content-Encoding", acceptedEncoding);
                await compressedResponse.CopyTo(destination, context, bufferSize);
            }
        }

        private static async Task CopyTo(this Stream source, Stream destination, IOwinContext context, int bufferSize)
        {
            source.Seek(0, SeekOrigin.Begin);
            context.Response.ContentLength = source.Length;
            await source.CopyToAsync(destination, bufferSize, context.Request.CallCancelled);
        }
    }
}